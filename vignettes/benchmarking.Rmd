---
title: "Benchmarking DelayedMatrixStats"
author: 
- name: "Peter Hickey"
  affiliation: Department of Biostatistics, Johns Hopkins Bloomberg School of Public Health
  email: peter.hickey@gmail.com
date: "`r BiocStyle::doc_date()`"
output: BiocStyle::html_document2
vignette: >
  %\VignetteIndexEntry{Vignette Title}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
editor_options: 
  chunk_output_type: console
---

```{r, include = FALSE, setup}
knitr::opts_chunk$set(echo = FALSE, comment = "#>", collapse = TRUE,
                      message = FALSE, warning = TRUE)
```

# Introduction

The `r BiocStyle::Biocpkg("DelayedArray")` package defines the *DelayedMatrix* 
class, for wrapping matrix-like objects to provide a unified interface. 

> Wrapping an matrix-like object (typically an on-disk object) in a DelayedMatrix object allows one to perform common matrix operations on it without loading the object in memory. In order to reduce memory usage and optimize performance, operations on the object are either delayed or executed using a block processing mechanism (see `?DelayedArray::DelayedMatrix` for further details)

A big 
advantage of this is we can use choose different matrix "*backends*" for 
storing the data while preserving a common interface. Examples of backends and 
data they are tailored towards using are given below:

| Class        | Package                                | Type of data                       | Example                           |
|--------------|----------------------------------------|------------------------------------|-----------------------------------|
| *matrix*     | `r BiocStyle::Rpackage("base")`        | Dense matrix                       | RNA-seq counts matrix             |
| *dgCMatrix*  | `r BiocStyle::CRANpkg("Matrix")`       | Sparse data                        | Single-cell RNA-seq counts matrix |
| *HDF5Matrix* | `r BiocStyle::Biocpkg("HDF5Array")`    | Dense matrix too large for memory  | Non-CpG methylation               |
| *RleArray*   | `r BiocStyle::Biocpkg("DelayedArray")` | Data with runs of identical values | Sequencing coverage               |

# Test data

```{r, test_data}
library(DelayedMatrixStats)
library(Matrix)
library(HDF5Array)
library(microbenchmark)
library(profvis)

times <- 10

dense_matrix <- DelayedArray(matrix(runif(20000 * 600), nrow = 20000,
                                    ncol = 600))
# 60% zero elements
sparse_matrix <- seed(dense_matrix)
zero_idx <- sample(length(sparse_matrix), 0.6 * length(sparse_matrix))
sparse_matrix[zero_idx] <- 0
sparse_matrix <- DelayedArray(Matrix::Matrix(sparse_matrix, sparse = TRUE))

# HDF5-backed dense matrix
# hdf5_matrix <- as(dense_matrix, "HDF5Array")

# Run-length encoded column matrix
rle_matrix <- RleArray(Rle(sample(2L, 200000 * 6 / 10, replace = TRUE), 100),
                       dim = c(2000000, 6))
```


We will benchmark the 
`r BiocStyle::Githubpkg("PeteHaitch", "DelayedMatrixStats")` package using 
different types of matrix-like data:

- `dense_matrix`: A dense *matrix* with `r ncol(dense_matrix)` columns and `r nrow(dense_matrix)` rows (`r pryr::object_size(dense_matrix)`)
- `sparse_matrix`: A sparse *dgcMatrix* with `r ncol(sparse_matrix)` columns and `r nrow(sparse_matrix)` rows where `r round(100 * sum(sparse_matrix == 0) / length(sparse_matrix), 2)`% of entries are zero (`r pryr::object_size(sparse_matrix)`)
- `rle_matrix`: An run-length encoded column *RleMatrix* with `r ncol(rle_matrix)` columns and `r nrow(rle_matrix)` rows  (`r pryr::object_size(rle_matrix)`)

Obviously, this is not a comprehensive set of inputs. Rather, it chosen to be 
somewhat representative of some typical genomics data.

Timings are measured using the `r BiocStyle::CRANpkg("microbenchmark")` and 
memory allocations measured using the `r BiocStyle::CRANpkg("profvis")` package.

## `colSums2()`

We compare the `DelayedArray::colSums()` method, which uses the 
block-processing algorithm, to the `DelayedMatrixStats::colSums2()` method, 
which uses tailored algorithms depending on the *seed* of the *DelayedMatrix* 
and to the `DelayedMatrixStats:::.colSums2()` method that acts directly on the 
seed of the *DelayedMatrix* object[^dotted_method]

[^dotted_method]: `DelayedMatrixStats:::.colSums2()` shouldn't be called by the user because it does not realise delayed operations. It is used here for demonstration purposes on a "*pristine*" DelayedMatrix to measure the additional overhead of S4 methods

### Pristine *DelayedMatrix*

```{r, colSums2}
microbenchmark(DelayedArray::colSums(dense_matrix),
               DelayedMatrixStats::colSums2(dense_matrix),
               DelayedMatrixStats:::.colSums2(seed(dense_matrix)),
               times = times)
profvis(DelayedArray::colSums(dense_matrix))
profvis(DelayedMatrixStats::colSums2(dense_matrix))

microbenchmark(DelayedArray::colSums(sparse_matrix),
               DelayedMatrixStats::colSums2(sparse_matrix),
               DelayedMatrixStats:::.colSums2(seed(sparse_matrix)),
               Matrix::colSums(seed(sparse_matrix)), 
               times = times)
profvis(DelayedArray::colSums(sparse_matrix))
profvis(DelayedMatrixStats::colSums2(sparse_matrix), interval = 0.005)

microbenchmark(DelayedArray::colSums(rle_matrix),
               DelayedMatrixStats::colSums2(rle_matrix),
               DelayedMatrixStats:::.colSums2(seed(rle_matrix)), 
               times = times)

profvis(DelayedArray::colSums(rle_matrix))
profvis(DelayedMatrixStats::colSums2(rle_matrix), interval = 0.005)
```

### With row subsetting

```{r, colSums2_with_rows}
i <- sample(nrow(dense_matrix), nrow(dense_matrix) / 10)
microbenchmark(DelayedArray::colSums(dense_matrix[i, ]),
               DelayedMatrixStats::colSums2(dense_matrix, rows = i),
               times = times)
profvis(DelayedArray::colSums(dense_matrix[i, ]))
profvis(DelayedMatrixStats::colSums2(dense_matrix, rows = i))

microbenchmark(DelayedArray::colSums(sparse_matrix[i, ]),
               DelayedMatrixStats::colSums2(sparse_matrix, rows = i),
               times = times)
profvis(DelayedArray::colSums(sparse_matrix[i, ]))
profvis(DelayedMatrixStats::colSums2(sparse_matrix, rows = i))

i <- sample(nrow(rle_matrix), nrow(rle_matrix) / 10)
microbenchmark(DelayedArray::colSums(rle_matrix[i, ]),
               DelayedMatrixStats::colSums2(rle_matrix, rows = i),
               times = times)
profvis(DelayedArray::colSums(rle_matrix[i, ]))
profvis(DelayedMatrixStats::colSums2(rle_matrix, rows = i), interval = 0.005)
```

### With column subsetting

```{r, colSums2_with_cols}
j <- sample(ncol(dense_matrix), ncol(dense_matrix) / 10)
microbenchmark(DelayedArray::colSums(dense_matrix[, j]),
               DelayedMatrixStats::colSums2(dense_matrix, cols = j),
               times = times)
profvis(DelayedArray::colSums(dense_matrix[, j]))
profvis(DelayedMatrixStats::colSums2(dense_matrix, cols = j))

microbenchmark(DelayedArray::colSums(sparse_matrix[, j]),
               DelayedMatrixStats::colSums2(sparse_matrix, cols = j),
               times = times)
profvis(DelayedArray::colSums(sparse_matrix[, j]))
profvis(DelayedMatrixStats::colSums2(sparse_matrix, cols = j))

j <- sample(ncol(rle_matrix), ncol(rle_matrix) / 2)
microbenchmark(DelayedArray::colSums(rle_matrix[, j]),
               DelayedMatrixStats::colSums2(rle_matrix, cols = j),
               times = times)
profvis(DelayedArray::colSums(rle_matrix[, j]))
profvis(DelayedMatrixStats::colSums2(rle_matrix, cols = j), interval = 0.005)
```

### With row and column subsetting

```{r, colSums2_with_rows_and_cols}
i <- sample(nrow(dense_matrix), nrow(dense_matrix) / 10)
j <- sample(ncol(dense_matrix), ncol(dense_matrix) / 10)
microbenchmark(DelayedArray::colSums(dense_matrix[i, j]),
               DelayedMatrixStats::colSums2(dense_matrix, rows = i, cols = j),
               times = times)
microbenchmark(DelayedArray::colSums(sparse_matrix[i, j]),
               DelayedMatrixStats::colSums2(sparse_matrix, rows = i, cols = j),
               times = times)
i <- sample(nrow(rle_matrix), nrow(rle_matrix) / 10)
j <- sample(ncol(rle_matrix), ncol(rle_matrix) / 2)
microbenchmark(DelayedArray::colSums(rle_matrix[i, j]),
               DelayedMatrixStats::colSums2(rle_matrix, rows = i, cols = j),
               times = times)
```

### With delayed ops

```{r, colSums2_with_delayed_ops}
microbenchmark(DelayedArray::colSums(dense_matrix ^ 2),
               DelayedMatrixStats::colSums2(dense_matrix ^ 2),
               times = times)
microbenchmark(DelayedArray::colSums(sparse_matrix ^ 2),
               DelayedMatrixStats::colSums2(sparse_matrix ^ 2),
               times = times)
microbenchmark(DelayedArray::colSums(rle_matrix ^ 2),
               DelayedMatrixStats::colSums2(rle_matrix ^ 2),
               times = times)
```

### Summary

**TODO**

# Session Info

```{r, session_info}
devtools::session_info()
```
